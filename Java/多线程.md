# 多线程

## 简介

### Process 与 Thread

* 程序是指指令和数据的有序集合，是一个静态的概念
* 进程是程序的一次执行过程
* 一个进程至少包含一个线程



## 线程创建

### Thread、Runnable、Callable

#### Thread

* 继承 Thread 类
* 重写 `run()` 方法
* 创建子类实例，调用 `start()` 方法启动线程
* 不建议使用：避免 OOP 单继承局限性



#### Runnable

* 实现 Runnable 接口

* 实现 `run()` 方法

* 创建线程对象，对实现类进行代理，调用 `start()` 方法启动线程

  ```java
  new Thread(实现类实例).start();
  ```

* 推荐使用：避免单继承局限性，方便同一个对象被多个线程使用




#### Callable

* 实现 Callable<> 接口，泛型为返回值的类型

* 重写 `call()` 方法，需要抛出异常

* 创建目标对象

* 创建执行服务，设置线程池的容量

  ```java
  ExecutorService ser = Executor.newFixedThreadPool(1);
  ```

* 提交执行

  ```java
  Future<Boolean> result = ser.submit(t1);
  ```

* 获取结果

  ```java
  boolean rs = result.get();
  ```

* 关闭服务

  ```java
  ser.shutdownNow();
  ```



> 总结
>
> Thread、Runnable 开启的多线程和 main() 主线程相互独立，主线程结束后，多线程仍会继续执行
>
> Callable 在提交执行时提交多次，才能开启多个相互独立的多线程，但超过线程池容量的提交不会被执行，多线程可以有返回值给主线程，主线程在关闭服务后才会继续执行后面的代码，相当于 Go 中的等待组



## 静态代理

静态代理模式总结：

* 真实对象和代理对象都要实现同一个接口
* 代理对象代理真实对象



好处：

* 代理对象可以做很多真实对象做不了的事情
* 真实对象专注做自己的事情



## 线程状态

![](C:\Users\lenovo\Desktop\java\images\屏幕截图(25).png)

> Thread.State

线程状态。线程可以处于以下状态之一：

* NEW

  尚未启动的线程处于此状态

* RUNNABLE

  在 Java 虚拟机中执行的线程处于此状态

* BLOCKED

  被阻塞等待监视器锁定的线程处于此状态

* WATTING

  正在等待另一个线程执行特定动作的线程处于此状态

* TIMED_WATTING

  正在等待另一个线程执行动作达到指定等待时间的线程处于此状态

* TERMINATED

  已退出的线程处于此状态

## 线程方法

| 方法                           | 说明                                     |
| ------------------------------ | ---------------------------------------- |
| setPriority(int newPriority)   | 更改线程的优先级                         |
| static void sleep(long millis) | 在指定的毫秒数内让当前正在执行的线程休眠 |
| void join()                    | 等待该线程终止                           |
| static void yield()            | 暂停当前正在执行的线程，并执行其它线程   |
| void interrupt()               | 中断线程，别用这个方法                   |
| boolean isAlive()              | 测试线程是否处于活动状态                 |



> 停止线程

* 不推荐使用 JDK 提供的 `stop()`、`destroy()` 方法【已废弃】

* 推荐线程自己停下来

* 建议使用一个标识位进行终止变量，当 `flag=false` 是，则终止线程运行

  ```java
  public class TestStop implements Runnable {
      // 1.线程中定义线程体使用的标识
      private boolean flag = true;
      
      @Override
      public void run() {
          // 2.线程体使用该标识
          while (flag) {
              System.out.println("run... Thread");
          }
      }
      
      // 3.对外提供方法改变标识
      public void stop() {
          this.flag = false;
      }
  }
  ```



> 线程休眠

* sleep(时间) 指定当前线程阻塞的毫秒数
* sleep 存在异常 InterruptedException
* sleep 时间达到后线程进入就绪状态
* sleep 可以模拟网络延时，倒计时等
* 每一个对象都有一个锁，sleep 不会释放锁



> 线程礼让

* 礼让线程，让当前正在执行的线程暂停，但不阻塞
* 将线程从运行状态转为就绪状态
* 让 cpu 重新调度，礼让不一定成功



> join

* join 合并线程，等待此线程执行完成后，再执行其它线程，其他线程阻塞




## 线程优先级

* Java 提供一个线程调度器来监控程序中启动后进入就绪状态的所有线程，线程调度器按照优先级决定应该调度哪个线程来执行
* 线程的优先级用数字来表示，范围从1~10
  * `Thread.MIN_PRIORITY` = 1;
  * `Thread.MAX_PRIORITY` = 10;
  * `Thread.NORM_PRIORITY` = 5;
* 获取优先级：`getPriority()`
* 改变优先级：`setPriority()`



## 守护线程

* 线程分为用户线程和守护线程
* 虚拟机必须确保用户线程执行完毕
* 虚拟机不用等待守护线程执行完毕

```java
new Thread().setDaemon(true);
```



## 线程同步

* 并发：同一个资源被多个线程同时操作
* 为了保证数据在方法中被访问时的正确性，在访问时加入锁机制 synchronized，当一个线程获得对象的排它锁，独占资源，其它线程必须等待，使用后释放锁即可。存在以下问题：
  * 一个线程持有锁会导致其它所有需要此锁的线程挂起
  * 在多线程竞争下，加锁、释放锁会导致比较多的上下文切换和调度延时，引起性能问题
  * 如果一个优先级高的线程等待一个优先级低的线程释放锁，会导致优先级倒置，引起性能问题



## 同步方法和同步代码块

> 同步方法

```java
public synchronized void method(int args) {}
```

* synchronized 方法控制”对象“的访问，每个对象对应一把锁，每个 synchronized 方法都必须获得调用该方法的对象的锁才能执行，否则线程会阻塞，方法一旦执行，就独占该锁，知道方法返回才释放锁，后面被阻塞的线程才能获得这个锁，继续执行
* 缺点：若将一个方法申明为 synchronized 将会影响效率

> 同步代码块

```java
synchronized (Obj) {}
```

* Obj 称为同步监视器
  * Obj 可以是任何对象，但是推荐使用共享资源作为同步监视器
  * 同步方法中无需指定同步监视器，因为同步方法的同步监视器就是 this
* 同步监视器的执行过程
  * 第一个线程访问，锁定同步监视器，执行其中代码
  * 第二个线程访问，发现同步监视器被锁定，无法访问
  * 第一个线程访问完毕，解锁同步监视器
  * 第二个线程访问，发现同步监视器没有锁，然后锁定并访问



## 死锁

* 多个线程各自占有一些共享资源，并且互相等待其它线程占有的资源才能运行，而导致两个或者多个线程都在等待对方释放资源，都停止执行的情形。某一个同步代码块同时拥有”两个以上对象的锁“时，就可能会发生”死锁“的问题

* 产生死锁的四个必要条件

  1. 互斥条件：一个资源每次只能被一个进程使用
  2. 请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放
  3. 不剥夺条件：进程已获得的资源，在未使用完之前，不能强行剥夺
  4. 循环等待条件：若干进程之间形成一种头尾相接的循环等待资源关系

  > 上面列出了死锁的四个必要条件，只要想办法破坏其中的任意一个或多个条件就可以避免死锁发生



## Lock（锁）

* 从 JDK 5.0 开始，Java 提供了更强大的线程同步机制——通过显式定义同步锁对象来实现同步。同步锁使用 Lock 对象充当。
* java.util.concurrent.locks.Lock 接口是控制多个线程对共享资源进行访问的工具。锁提供了对共享资源的独占访问，每次只能有一个线程对 Lock 对象加锁，线程开始访问共享资源之前应先获得 Lock 对象
* ReentrantLock 类（可重入锁）实现了 Lock，它拥有与 synchronized 相同的并发性和内存语义，在实现线程安全的控制中，比较常用的是 ReentrantLock，刻意显式加锁、释放锁



## synchronized 与 Lock 的对比

* Lock 是显示锁（手动开启和释放锁，别忘记释放锁），synchronized 是隐式锁，出了作用域自动释放

* Lock 只有代码块锁，synchronized 有代码块锁和方法锁

* 使用 Lock 锁，JVM 将花费较少的时间来调度线程，性能更好。并且具有更好的扩展性（提供更多的子类）

* 优先使用顺序：

  Lock > 同步代码块（已经进入了方法体，分配了相应的资源）> 同步方法（在方法体之外）



## 线程通信

* Java 提供了几个方法解决线程之间的通信问题

  | 方法名             | 作用                                                         |
  | ------------------ | ------------------------------------------------------------ |
  | wait()             | 表示线程一直等待，直到其它线程通知，与 sleep 不同，会释放锁  |
  | wait(long timeout) | 指定等待的毫秒数                                             |
  | notify()           | 唤醒一个处于等待状态的线程                                   |
  | notifyAll()        | 唤醒同一个对象上所有调用 wait() 方法的线程，优先级别搞得线程优先调度 |

* 注意：均是 Object 类的方法，都只能在同步方法或者同步代码块中使用，否则会抛出异常 `IllegalMonitorStateException`



## 线程协作

> 生产者消费者模式

* 解决方式1

  并发协作模型“生产者/消费者模型” -> 管程法

  * 生产者：负责生产数据的模块（可能是方法、对象、线程、进程）
  * 消费者：负责处理数据的模块（可能是方法、对象、线程、进程）
  * 缓冲区：生产者将生产好的数据放入缓冲区，消费者从缓冲区拿出数据

* 解决方式2

  并发协作模型“生产者/消费者模型” -> 信号灯法



## 线程池

> 背景

经常创建和销毁、使用量特别大的资源，比如并发情况下的线程，对性能影响很大

> 思路

提前创建好多个线程，放入线程池中，使用时直接获取，使用完放回池子中。可以避免频繁创建销毁、实现重复利用。

> 好处

* 提高响应速度（减少了创建新线程的时间）
* 降低资源消耗（重复利用线程池中线程，不需要每次都创建）
* 便于线程管理
  * corePoolSize：核心池的大小
  * maximumPoolSize：最大线程数
  * keepAliveTime：线程没有任务时最多保持多长时间后会终止

> 使用

* JDK 5.0后提供了线程池相关 API：ExecutorService 和 Executors
* ExecutorService：真正的线程池接口。常见子类 ThreadPoolExecutor
  * `void execute(Runnable command)`：执行任务/命令，没有返回值，一般用来执行 Runnable
  * `<T> Future<T> submit(Callable<T> task)`：执行任务，有返回值，一般用来执行 Callable
  * `void shutdown()`：关闭连接池
* Executors：工具类、线程池的工厂类，用于创建并返回不同类型的线程池
